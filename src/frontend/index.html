<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tapestry Frontend (SHA-1)</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        height: 100vh;
        margin: 0;
        background-color: #f0f2f5;
      }
      .sidebar {
        width: 350px;
        padding: 20px;
        border-right: 1px solid #ccc;
        background-color: #fff;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }
      .main-content {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        padding: 20px;
      }
      .ring-container {
        flex-grow: 1;
        position: relative;
        border: 1px solid #ddd;
        border-radius: 8px;
        background-color: #fafafa;
        overflow: hidden;
      }
      .log-container {
        height: 200px;
        border: 1px solid #ddd;
        overflow-y: scroll;
        padding: 10px;
        margin-top: 20px;
        background-color: #222;
        color: #0f0;
        font-family: monospace;
        font-size: 12px;
        border-radius: 8px;
      }
      .node {
        position: absolute;
        width: 50px;
        height: 50px;
        background-color: #007bff;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 10;
      }
      .node:hover {
        transform: scale(1.1);
        z-index: 20;
        background-color: #0056b3;
      }
      .details-panel {
        display: none;
        margin-top: 20px;
      }
      h2, h3 { color: #333; }
      button {
        padding: 8px 12px;
        border: none;
        background-color: #28a745;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 10px;
        margin-bottom: 5px;
      }
      button:hover { opacity: 0.9; }
      input {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        margin-bottom: 10px;
        width: calc(100% - 18px);
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 11px;
        margin-top: 10px;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 4px;
        text-align: center;
      }
      th { background-color: #f2f2f2; }
      .rt-cell { font-family: monospace; }
    </style>
  </head>
  <body>
    <div class="sidebar">
      <h2>Tapestry Controls</h2>
      <button onclick="addNode()">Spawn New Node</button>
      <hr />
      
      <div id="details-panel" class="details-panel">
        <h3 id="details-title">Node Details</h3>
        <p><strong>ID:</strong> <span id="node-id-full" style="font-family: monospace; word-break: break-all;"></span></p>
        <p><strong>Port:</strong> <span id="node-port"></span></p>
        
        <div id="details-content"></div>

        <h4>Actions</h4>
        <input id="key-input" placeholder="Object Key (e.g., 'my-file')" />
        <input id="value-input" placeholder="Content (e.g., 'Hello World')" />
        <button onclick="publish()">Store & Publish</button>
        <button onclick="find()">Find & Fetch</button>
      </div>
    </div>

    <div class="main-content">
      <div class="ring-container" id="ring-container"></div>
      <div class="log-container" id="log-container"></div>
    </div>

    <script>
      let selectedNode = null;
      const logContainer = document.getElementById("log-container");

      window.onload = () => {
        fetchNodes();
        connectWebSocket();
        setInterval(fetchNodes, 5000); // Auto-refresh nodes
      };

      async function fetchNodes() {
        try {
          const response = await fetch("/nodes");
          const nodes = await response.json();
          renderRing(nodes);
        } catch (e) {
          console.error("Failed to fetch nodes", e);
        }
      }

      function renderRing(nodes) {
        const ring = document.getElementById("ring-container");
        // Don't redraw if we are interacting (simple check)
        // ideally we diff, but for now just clear
        ring.innerHTML = "";
        
        const radius = Math.min(ring.clientWidth, ring.clientHeight) / 2 - 50;
        const centerX = ring.clientWidth / 2;
        const centerY = ring.clientHeight / 2;

        // Sort nodes by port to keep visual stability
        nodes.sort((a, b) => a.port - b.port);

        nodes.forEach((node, i) => {
          const angle = (i / nodes.length) * 2 * Math.PI;
          const x = centerX + radius * Math.cos(angle) - 25;
          const y = centerY + radius * Math.sin(angle) - 25;

          const nodeEl = document.createElement("div");
          nodeEl.className = "node";
          nodeEl.style.left = `${x}px`;
          nodeEl.style.top = `${y}px`;
          // Display port as label
          nodeEl.innerText = node.port;
          nodeEl.title = `Port: ${node.port}`;
          
          nodeEl.onclick = () => showNodeDetails(node);
          ring.appendChild(nodeEl);
        });
      }

      async function addNode() {
        await fetch("/add-node", { method: "POST" });
        setTimeout(fetchNodes, 500);
      }

      async function showNodeDetails(node) {
        selectedNode = node;
        try {
          const response = await fetch(`http://localhost:${node.httpPort}/status`);
          if (!response.ok) throw new Error("Node unreachable");
          const status = await response.json();

          document.getElementById("details-title").innerText = `Node ${status.port}`;
          document.getElementById("node-id-full").innerText = status.id;
          document.getElementById("node-port").innerText = status.port;

          let contentHtml = "";

          // Objects
          contentHtml += "<h4>Stored Objects</h4>";
          if (status.objects && status.objects.length > 0) {
            contentHtml += "<table><tr><th>Key</th><th>Data</th></tr>";
            status.objects.forEach(o => {
              contentHtml += `<tr><td>${o.Key}</td><td>${o.Data}</td></tr>`;
            });
            contentHtml += "</table>";
          } else {
            contentHtml += "<p><i>Empty</i></p>";
          }

          // Backpointers
          contentHtml += "<h4>Backpointers</h4>";
          if (status.backpointers && status.backpointers.length > 0) {
             contentHtml += "<ul>";
             status.backpointers.forEach(bp => {
                 contentHtml += `<li style="font-size:10px; font-family:monospace">${bp}</li>`;
             });
             contentHtml += "</ul>";
          } else {
            contentHtml += "<p><i>None</i></p>";
          }

          // Routing Table (First 8 Levels)
          contentHtml += "<h4>Routing Table (Top 8 Levels)</h4>";
          if (status.routingTable && status.routingTable.length > 0) {
            contentHtml += "<table><tr><th>Lvl</th>";
            for(let k=0; k<16; k++) contentHtml += `<th>${k.toString(16).toUpperCase()}</th>`;
            contentHtml += "</tr>";

            for (let i = 0; i < 8 && i < status.routingTable.length; i++) {
              contentHtml += `<tr><td><strong>${i}</strong></td>`;
              status.routingTable[i].forEach(cell => {
                const val = cell === "." ? "." : "â–ˆ"; // Use block for occupied, or cell for full ID
                const title = cell === "." ? "" : cell;
                contentHtml += `<td class="rt-cell" title="${title}">${val}</td>`;
              });
              contentHtml += "</tr>";
            }
            contentHtml += "</table>";
          }

          document.getElementById("details-content").innerHTML = contentHtml;
          document.getElementById("details-panel").style.display = "block";
        } catch (e) {
          alert("Could not fetch node details. Is it running?");
        }
      }

      async function publish() {
        if (!selectedNode) return;
        const key = document.getElementById("key-input").value;
        const value = document.getElementById("value-input").value;
        if(!key || !value) return alert("Enter key and value");

        try {
            await fetch(`http://localhost:${selectedNode.httpPort}/publish`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ key, value }),
            });
            log("Published object: " + key);
            showNodeDetails(selectedNode); 
        } catch(e) { alert(e); }
      }

      async function find() {
        if (!selectedNode) return;
        const key = document.getElementById("key-input").value;
        if(!key) return alert("Enter key");

        try {
            const response = await fetch(`http://localhost:${selectedNode.httpPort}/find`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ key }),
            });
            if (response.ok) {
                const obj = await response.json();
                alert(`SUCCESS!\nKey: ${obj.Key}\nData: ${obj.Data}`);
                log(`Found object ${key}: ${obj.Data}`);
            } else {
                alert("Object not found in network.");
                log(`Lookup failed for ${key}`);
            }
        } catch(e) { alert(e); }
      }

      function connectWebSocket() {
        const ws = new WebSocket("ws://localhost:3000/logs");
        ws.onmessage = (event) => log(event.data);
        ws.onclose = () => setTimeout(connectWebSocket, 1000);
      }

      function log(msg) {
          const div = document.createElement("div");
          div.innerText = `> ${msg}`;
          logContainer.appendChild(div);
          logContainer.scrollTop = logContainer.scrollHeight;
      }
    </script>
  </body>
</html>